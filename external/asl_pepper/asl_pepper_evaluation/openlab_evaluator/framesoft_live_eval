#!/usr/bin/env python
from matplotlib import pyplot as plt
import numpy as np
from pose2d import Pose2D, apply_tf, apply_tf_to_pose, inverse_pose2d, posemsg_to_pose2d
from pyniel.ros_tools.rosbag_end_detector import RosbagEndDetector
import rospy
import tf
from tf2_ros import TransformException

FIXED_FRAME = "gmap"
ROBOT_FRAME = "base_footprint"

ROSBAG_NAME = rospy.get_param("/rosbag_name")

COUNT_DETECTIONS = False

class Evaluator(object):
    def __init__(self):
        self.RECORDING = True
        self.tp_msgs = []
        self.tp_msg_in_fixed = []
        self.tp_robot_in_fixed = []
        self.laser_msgs = []
        self.yolo_msgs = []
        # 1 - Node Init
        rospy.init_node('framesoft_eval')
        self.tf_listener = tf.TransformListener()
        # 2 - Subscribers now active
        from frame_msgs.msg import TrackedPersons
        from frame_msgs.msg import DetectedPersons
        rospy.Subscriber("/rwth_tracker/tracked_persons", TrackedPersons, self.tp_cb, queue_size=1)
        if COUNT_DETECTIONS:
            rospy.Subscriber("/drow_detected_persons_front", DetectedPersons, self.laser_cb, queue_size=1)
            rospy.Subscriber("/drow_detected_persons_rear", DetectedPersons, self.laser_cb, queue_size=1)
            rospy.Subscriber("/detected_persons/yolo", DetectedPersons, self.yolo_cb, queue_size=1)
        # 3 - End detector active
        self.rosbag_end_detector = RosbagEndDetector(self.rosbag_end_callback)
        # 4 - Spin (waits)
        rospy.spin()

    def tp_cb(self, msg):
        if not self.RECORDING:
            return
        msg_in_fixed = self.wait_for_tf(FIXED_FRAME, msg.header.frame_id)
        robot_in_fixed = self.wait_for_tf(FIXED_FRAME, ROBOT_FRAME)
        if msg_in_fixed is None or robot_in_fixed is None:
            return
        self.tp_msgs.append(msg)
        self.tp_msg_in_fixed.append(msg_in_fixed)
        self.tp_robot_in_fixed.append(robot_in_fixed)

    def laser_cb(self, msg):
        if not self.RECORDING:
            return
        self.laser_msgs.append(msg)

    def yolo_cb(self, msg):
        if not self.RECORDING:
            return
        self.yolo_msgs.append(msg)

    def rosbag_end_callback(self):
        self.RECORDING = False
        print("Rosbag end/pause detected!")
        tp_detections_in_fixed = []
        tp_detection_times = []
        n_laser_detections = 0
        n_yolo_detections = 0
        n_detections_in_tracking_frames = []
        n_detection_times = []
        for msg, pose2d in zip(self.tp_msgs, self.tp_msg_in_fixed):
            n_detections_in_tracking_frames.append(len(msg.tracks))
            n_detection_times.append(msg.header.stamp.to_sec())
            for detection in msg.tracks:
                tp_detections_in_fixed.append(apply_tf_to_pose(posemsg_to_pose2d(detection.pose.pose), pose2d))
                tp_detection_times.append(msg.header.stamp.to_sec())
        for msg in self.laser_msgs:
            n_laser_detections += len(msg.detections)
        for msg in self.yolo_msgs:
            n_yolo_detections += len(msg.detections)
        # Convert tfs to robot track
        robot_track = np.array(self.tp_robot_in_fixed)
        detections = np.array(tp_detections_in_fixed)
        n_detections_in_tracking_frames = np.array(n_detections_in_tracking_frames)
        n_detection_times = np.array(n_detection_times)
        avg_detections_per_tracking_frames = np.mean(n_detections_in_tracking_frames)
        # Output
        rospy.logwarn("Total detections: {} detections, {} RGB-D, {} LiDAR".format(len(detections), n_yolo_detections, n_laser_detections))
        rospy.logwarn("Average Detections Per Tracking Frame: {}".format(avg_detections_per_tracking_frames))
        plt.figure()
        plt.scatter(robot_track[:,0], robot_track[:,1], marker='o', facecolor=(0,0,0,0), edgecolor='k', zorder=1, label='robot track')
        plt.scatter(detections[:,0], detections[:,1], c=tp_detection_times, marker='+', zorder=0, label='detections')
        plt.gca().legend()
        plt.title("Robot track and detections in map frame ({})".format(ROSBAG_NAME))
        plt.figure()
        plt.plot(n_detection_times, n_detections_in_tracking_frames)
        plt.title("Detections per tracking frame")
        plt.show()

    def wait_for_tf(self, parent, child, tf_timeout=None):
        if tf_timeout is None:
            tf_timeout = rospy.Duration(0.1)
        try:
            time = rospy.Time.now()
            tf_info = [parent, child, time]
            self.tf_listener.waitForTransform(*(tf_info + [tf_timeout]))
            tf_child_in_parent = self.tf_listener.lookupTransform(*tf_info)
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException,
                TransformException) as e:
            print("[{}.{}] tf to refmap frame for time {}.{} not found: {}".format(
                rospy.Time.now().secs, rospy.Time.now().nsecs, time.secs, time.nsecs, e))
            return None
        pose2d_child_in_parent = Pose2D(tf_child_in_parent)
        return pose2d_child_in_parent

if __name__=="__main__":
    Evaluator()
